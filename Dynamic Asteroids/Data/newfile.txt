using DynamicAsteroids.AsteroidEntities;
using VRageMath;
using ProtoBuf;

namespace DynamicAsteroids
{
    [ProtoContract]
    public struct AsteroidNetworkMessage
    {
        [ProtoMember(1)]
        public Vector3D Position;

        [ProtoMember(2)]
        public float Size;

        [ProtoMember(3)]
        public Vector3D InitialVelocity;

        [ProtoMember(4)]
        public Vector3D AngularVelocity;

        [ProtoMember(5)]
        public AsteroidType Type;

        [ProtoMember(6)]
        public bool IsSubChunk;

        [ProtoMember(7)]
        public long EntityId;

        [ProtoMember(8)]
        public bool IsRemoval;

        [ProtoMember(9)]
        public bool IsInitialCreation;

        public AsteroidNetworkMessage(Vector3D position, float size, Vector3D initialVelocity, Vector3D angularVelocity, AsteroidType type, bool isSubChunk, long entityId, bool isRemoval, bool isInitialCreation)
        {
            Position = position;
            Size = size;
            InitialVelocity = initialVelocity;
            AngularVelocity = angularVelocity;
            Type = type;
            IsSubChunk = isSubChunk;
            EntityId = entityId;
            IsRemoval = isRemoval;
            IsInitialCreation = isInitialCreation;
        }
    }
}﻿using DynamicAsteroids.AsteroidEntities;
using System;
using VRageMath;

namespace DynamicAsteroids
{
    public static class AsteroidSettings
    {
        public static bool EnableLogging = true;
        public static bool EnablePersistence = false; //barely works, don't touch this
        public static bool EnableMiddleMouseAsteroidSpawn = false;  //debug

        public static int SaveStateInterval = 600; // Default: 600 ticks (10 seconds)
        public static int NetworkMessageInterval = 120; // Default: 120 ticks (2 seconds)
        public static int SpawnInterval = 6; // Default: 600 ticks (10 seconds)
        public static int UpdateInterval = 120; // Default: 120 ticks (2 seconds)

        public static int MaxAsteroidCount = 1000;
        public static int AsteroidSpawnRadius = 10000;
        //TODO: make these velocities only affect a % of asteroids with an option
        //note: these are absolutely awful for performance, thousands of moving entities etc.
        public static int AsteroidVelocityBase = 0;
        public static double VelocityVariability = 0;
        public static double AngularVelocityVariability = 0;

        public static double MinDistanceFromVanillaAsteroids = 1000; // 1 km
        public static double MinDistanceFromPlayer = 1; // Minimum distance from the player to spawn new asteroids
        public static int Seed = 69420; // Default seed, can be set dynamically

        public static double IceWeight = 99;
        public static double StoneWeight = 0.5;  // Represents silicate materials
        public static double IronWeight = 0.25;
        public static double NickelWeight = 0.05;
        public static double CobaltWeight = 0.05;
        public static double MagnesiumWeight = 0.05;
        public static double SiliconWeight = 0.05;
        public static double SilverWeight = 0.05;
        public static double GoldWeight = 0.05;
        public static double PlatinumWeight = 0.05;
        public static double UraniniteWeight = 0.05;

        public static float BaseIntegrity = 1f;
        public static float MinAsteroidSize = 50f;
        public static float MaxAsteroidSize = 250f;
        public static float MinSubChunkSize = 5f;

        public static double SubChunkVelocityMin = 1.0;
        public static double SubChunkVelocityMax = 5.0;
        public static double SubChunkAngularVelocityMin = 0.01;
        public static double SubChunkAngularVelocityMax = 0.1;

        public static int[] IceDropRange = { 1000, 10000 };
        public static int[] StoneDropRange = { 1000, 10000 };
        public static int[] IronDropRange = { 500, 2500 };
        public static int[] NickelDropRange = { 500, 2500 };
        public static int[] CobaltDropRange = { 500, 2500 };
        public static int[] MagnesiumDropRange = { 500, 2500 };
        public static int[] SiliconDropRange = { 500, 2500 };
        public static int[] SilverDropRange = { 500, 2500 };
        public static int[] GoldDropRange = { 500, 2500 };
        public static int[] PlatinumDropRange = { 500, 2500 };
        public static int[] UraniniteDropRange = { 500, 2500 };

        public static SpawnableArea[] ValidSpawnLocations =
        {
    new SpawnableArea
    {
        CenterPosition = new Vector3D(148001024.50, 1024.50, 1024.50),
        Normal = new Vector3D(1, 10, 0.5).Normalized(),
        Radius = 60268000 * 2.5,
        InnerRadius = 60268000 * 1.2,
        HeightFromCenter = 1000,
    }
};

        public static bool CanSpawnAsteroidAtPoint(Vector3D point, out Vector3D velocity)
        {
            foreach (var area in ValidSpawnLocations)
            {
                if (area.ContainsPoint(point))
                {
                    velocity = area.VelocityAtPoint(point);
                    return true;
                }
            }

            velocity = Vector3D.Zero;
            return false;
        }

        public static bool PlayerCanSeeRings(Vector3D point)
        {
            foreach (var area in ValidSpawnLocations)
                if (area.ContainsPoint(point))
                    return true;
            return false;
        }

        private static Random rand = new Random(Seed);

        public static AsteroidType GetAsteroidType(Vector3D position)
        {
            // Calculate the total weight
            double totalWeight = IceWeight + StoneWeight + IronWeight + NickelWeight + CobaltWeight +
                                 MagnesiumWeight + SiliconWeight + SilverWeight + GoldWeight + PlatinumWeight + UraniniteWeight;

            // Generate a random value between 0 and totalWeight
            double randomValue = rand.NextDouble() * totalWeight;

            // Determine the asteroid type based on the random value and weights
            if (randomValue < IceWeight) return AsteroidType.Ice;
            randomValue -= IceWeight;
            if (randomValue < StoneWeight) return AsteroidType.Stone;
            randomValue -= StoneWeight;
            if (randomValue < IronWeight) return AsteroidType.Iron;
            randomValue -= IronWeight;
            if (randomValue < NickelWeight) return AsteroidType.Nickel;
            randomValue -= NickelWeight;
            if (randomValue < CobaltWeight) return AsteroidType.Cobalt;
            randomValue -= CobaltWeight;
            if (randomValue < MagnesiumWeight) return AsteroidType.Magnesium;
            randomValue -= MagnesiumWeight;
            if (randomValue < SiliconWeight) return AsteroidType.Silicon;
            randomValue -= SiliconWeight;
            if (randomValue < SilverWeight) return AsteroidType.Silver;
            randomValue -= SilverWeight;
            if (randomValue < GoldWeight) return AsteroidType.Gold;
            randomValue -= GoldWeight;
            if (randomValue < PlatinumWeight) return AsteroidType.Platinum;
            return AsteroidType.Uraninite;
        }
        public static float GetAsteroidSize(Vector3D position)
        {
            Random rand = new Random(Seed + position.GetHashCode());
            return MinAsteroidSize + (float)rand.NextDouble() * (MaxAsteroidSize - MinAsteroidSize);
        }

        public static double GetRandomAngularVelocity(Random rand)
        {
            return AngularVelocityVariability * rand.NextDouble();
        }

        public static double GetRandomSubChunkVelocity(Random rand)
        {
            return SubChunkVelocityMin + rand.NextDouble() * (SubChunkVelocityMax - SubChunkVelocityMin);
        }

        public static double GetRandomSubChunkAngularVelocity(Random rand)
        {
            return SubChunkAngularVelocityMin + rand.NextDouble() * (SubChunkAngularVelocityMax - SubChunkAngularVelocityMin);
        }
    }

    public class SpawnableArea
    {
        public Vector3D CenterPosition;
        public Vector3D Normal;
        public double Radius;
        public double InnerRadius;
        public double HeightFromCenter;

        public bool ContainsPoint(Vector3D point)
        {
            point -= CenterPosition;
            double pointDistanceSq = point.LengthSquared();

            if (pointDistanceSq > Radius * Radius || pointDistanceSq < InnerRadius * InnerRadius)
                return false;

            if (Math.Abs(Vector3D.Dot(point, Normal)) > HeightFromCenter)
                return false;

            return true;
        }

        public Vector3D VelocityAtPoint(Vector3D point)
        {
            return -(point - CenterPosition).Cross(Normal).Normalized() * AsteroidSettings.AsteroidVelocityBase;
        }
    }
}
﻿using DynamicAsteroids.AsteroidEntities;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VRageMath;

[ProtoContract]
public class AsteroidState
{
    [ProtoMember(1)]
    public Vector3D Position { get; set; }

    [ProtoMember(2)]
    public float Size { get; set; }

    [ProtoMember(3)]
    public AsteroidType Type { get; set; }

    [ProtoMember(4)]
    public long EntityId { get; set; } // Unique ID for each asteroid
}﻿using System;
using System.IO;
using DynamicAsteroids;
using Sandbox.ModAPI;

namespace SC.SUGMA
{
    internal class Log
    {
        private static Log I;
        private readonly TextWriter _writer;

        private Log()
        {
            MyAPIGateway.Utilities.DeleteFileInGlobalStorage("DynamicAsteroids.log");
            _writer = MyAPIGateway.Utilities
                .WriteFileInGlobalStorage(
                    "DynamicAsteroids.log"); // Only creating one debug.log to avoid clutter. Might change in the future.
            _writer.WriteLine(
                $"      Dynamic Asteroids - {(MyAPIGateway.Session.IsServer ? "Server" : "Client")} Debug Log\n===========================================\n");
            _writer.Flush();
        }

        public static void Info(string message)
        {
            if (AsteroidSettings.EnableLogging)
                I._Log(message);
        }

        public static void Exception(Exception ex, Type callingType, string prefix = "")
        {
            if (AsteroidSettings.EnableLogging)
                I._LogException(ex, callingType, prefix);
        }

        public static void Init()
        {
            Close();
            I = new Log();
        }

        public static void Close()
        {
            if (I != null)
            {
                Info("Closing log writer.");
                I._writer.Close();
            }

            I = null;
        }

        private void _Log(string message)
        {
            _writer.WriteLine($"{DateTime.UtcNow:HH:mm:ss}: {message}");
            _writer.Flush();
        }

        private void _LogException(Exception ex, Type callingType, string prefix = "")
        {
            if (ex == null)
            {
                _Log("Null exception! CallingType: " + callingType.FullName);
                return;
            }

            _Log(prefix + $"Exception in {callingType.FullName}! {ex.Message}\n{ex.StackTrace}\n{ex.InnerException}");
            MyAPIGateway.Utilities.ShowNotification($"{ex.GetType().Name} in Dynamic Asteroids! Check logs for more info.", 10000, "Red");
        }
    }
}﻿using System;
using System.Collections.Generic;
using DynamicAsteroids.AsteroidEntities;
using Sandbox.Game.EntityComponents;
using Sandbox.ModAPI;
using SC.SUGMA;
using VRage.Game.Components;
using VRage.Input;
using VRageMath;
using ProtoBuf;
using Sandbox.Game.Entities;

namespace DynamicAsteroids
{
    [MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]
    public class MainSession : MySessionComponentBase
    {
        public static MainSession I;
        public Random Rand;
        private int seed;
        public AsteroidSpawner _spawner = new AsteroidSpawner();
        private int _saveStateTimer;
        private int _networkMessageTimer;


        public override void LoadData()
        {
            I = this;
            Log.Init();

            try
            {
                Log.Info("Loading data in MainSession");
                if (MyAPIGateway.Session.IsServer)
                {
                    seed = (int)DateTime.UtcNow.Ticks; // Example seed based on current time
                    AsteroidSettings.Seed = seed;
                    Rand = new Random(seed);
                    _spawner.Init(seed);
                    if (AsteroidSettings.EnablePersistence) // Add this line
                    {
                        _spawner.LoadAsteroidState(); // Load asteroid states
                    }
                }

                MyAPIGateway.Multiplayer.RegisterMessageHandler(32000, OnMessageReceived);
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(MainSession));
            }
        }

        protected override void UnloadData()
        {
            try
            {
                Log.Info("Unloading data in MainSession");
                if (MyAPIGateway.Session.IsServer)
                {
                    if (AsteroidSettings.EnablePersistence) // Add this line
                    {
                        _spawner.SaveAsteroidState(); // Save asteroid states
                    }
                    _spawner.Close();
                }

                MyAPIGateway.Multiplayer.UnregisterMessageHandler(32000, OnMessageReceived);
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(MainSession));
            }

            Log.Close();
            I = null;
        }

        public override void UpdateAfterSimulation()
        {
            try
            {
                if (MyAPIGateway.Session.IsServer)
                {
                    _spawner.UpdateTick();

                    // Save asteroid states periodically
                    if (_saveStateTimer > 0)
                    {
                        _saveStateTimer--;
                    }
                    else
                    {
                        _spawner.SaveAsteroidState();
                        _saveStateTimer = AsteroidSettings.SaveStateInterval; // Use setting
                    }

                    // Batch and delay network messages
                    if (_networkMessageTimer > 0)
                    {
                        _networkMessageTimer--;
                    }
                    else
                    {
                        Log.Info($"Server: Sending network messages, asteroid count: {_spawner._asteroids.Count}");
                        _spawner.SendNetworkMessages();
                        _networkMessageTimer = AsteroidSettings.NetworkMessageInterval;
                    }
                }

                if (MyAPIGateway.Session?.Player?.Character != null && _spawner._asteroids != null)
                {
                    Vector3D characterPosition = MyAPIGateway.Session.Player.Character.PositionComp.GetPosition();
                    AsteroidEntity nearestAsteroid = FindNearestAsteroid(characterPosition);

                    if (nearestAsteroid != null)
                    {
                        Vector3D angularVelocity = nearestAsteroid.Physics.AngularVelocity;
                        string rotationString = $"({angularVelocity.X:F2}, {angularVelocity.Y:F2}, {angularVelocity.Z:F2})";

                        string message = $"Nearest Asteroid: {nearestAsteroid.EntityId} ({nearestAsteroid.Type})\nRotation: {rotationString}";
                        if (AsteroidSettings.EnableLogging)
                            MyAPIGateway.Utilities.ShowNotification(message, 1000 / 60);
                    }
                }

                if (AsteroidSettings.EnableMiddleMouseAsteroidSpawn && MyAPIGateway.Input.IsNewKeyPressed(MyKeys.MiddleButton))
                {
                    if (MyAPIGateway.Session != null)
                    {
                        var position = MyAPIGateway.Session.Player?.GetPosition() ?? Vector3D.Zero;
                        var velocity = MyAPIGateway.Session.Player?.Character?.Physics?.LinearVelocity ?? Vector3D.Zero;
                        AsteroidType type = DetermineAsteroidType(); // Determine the type of asteroid
                        AsteroidEntity.CreateAsteroid(position, Rand.Next(50), velocity, type);
                        Log.Info($"Asteroid created at {position} with velocity {velocity}");
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(MainSession));
            }
        }

        private void OnMessageReceived(byte[] message)
        {
            try
            {
                Log.Info($"Client: Received message of {message.Length} bytes");
                var asteroidMessages = MyAPIGateway.Utilities.SerializeFromBinary<List<AsteroidNetworkMessage>>(message);
                Log.Info($"Client: Deserialized {asteroidMessages.Count} asteroid messages"); foreach (var asteroidMessage in asteroidMessages)
                {
                    Log.Info($"Client: Received message to create/remove asteroid at {asteroidMessage.Position} with velocity {asteroidMessage.InitialVelocity} of type {asteroidMessage.Type}");

                    if (asteroidMessage.IsRemoval)
                    {
                        // Find and remove the asteroid with the given EntityId
                        var asteroid = MyEntities.GetEntityById(asteroidMessage.EntityId) as AsteroidEntity;
                        if (asteroid != null)
                        {
                            asteroid.Close();
                            Log.Info($"Client: Removed asteroid with ID {asteroidMessage.EntityId}");
                        }
                    }
                    else if (asteroidMessage.IsInitialCreation)
                    {
                        var asteroid = AsteroidEntity.CreateAsteroid(asteroidMessage.Position, asteroidMessage.Size, asteroidMessage.InitialVelocity, asteroidMessage.Type);
                        asteroid.Physics.AngularVelocity = asteroidMessage.AngularVelocity;
                        MyEntities.Add(asteroid);
                        Log.Info($"Client: Created initial asteroid with ID {asteroid.EntityId}");
                    }
                    else
                    {
                        if (asteroidMessage.IsSubChunk)
                        {
                            // Create the sub-chunk asteroid on the client
                            var subChunk = AsteroidEntity.CreateAsteroid(asteroidMessage.Position, asteroidMessage.Size, asteroidMessage.InitialVelocity, asteroidMessage.Type);
                            subChunk.Physics.AngularVelocity = asteroidMessage.AngularVelocity;
                            Log.Info($"Client: Created sub-chunk asteroid with ID {subChunk.EntityId}");
                        }
                        else
                        {
                            // Create the regular asteroid on the client
                            var asteroid = AsteroidEntity.CreateAsteroid(asteroidMessage.Position, asteroidMessage.Size, asteroidMessage.InitialVelocity, asteroidMessage.Type);
                            asteroid.Physics.AngularVelocity = asteroidMessage.AngularVelocity;
                            MyEntities.Add(asteroid);
                            Log.Info($"Client: Created asteroid with ID {asteroid.EntityId}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(MainSession));
            }
        }

        private AsteroidEntity FindNearestAsteroid(Vector3D characterPosition)
        {
            if (_spawner._asteroids == null) return null;

            AsteroidEntity nearestAsteroid = null;
            double minDistance = double.MaxValue;

            foreach (var asteroid in _spawner._asteroids)
            {
                double distance = Vector3D.DistanceSquared(characterPosition, asteroid.PositionComp.GetPosition());
                if (distance < minDistance)
                {
                    minDistance = distance;
                    nearestAsteroid = asteroid;
                }
            }

            return nearestAsteroid;
        }

        // This function determines the type of asteroid to spawn
        private AsteroidType DetermineAsteroidType()
        {
            int randValue = Rand.Next(0, 2); // Adjust as needed for more types
            return (AsteroidType)randValue;
        }

    }
}
﻿using System;
using System.IO;
using Sandbox.Definitions;
using Sandbox.Engine.Physics;
using Sandbox.Game;
using Sandbox.Game.Entities;
using Sandbox.ModAPI;
using SC.SUGMA;
using VRage;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.Entity;
using VRage.Game.ModAPI;
using VRage.Game.ModAPI.Interfaces;
using VRage.ModAPI;
using VRage.ObjectBuilders;
using VRage.ObjectBuilders.Private;
using VRage.Utils;
using VRageMath;
using CollisionLayers = Sandbox.Engine.Physics.MyPhysics.CollisionLayers;

namespace DynamicAsteroids.AsteroidEntities
{
    public enum AsteroidType
    {
        Ice,
        Stone,
        Iron,
        Nickel,
        Cobalt,
        Magnesium,
        Silicon,
        Silver,
        Gold,
        Platinum,
        Uraninite
    }

    public class AsteroidEntity : MyEntity, IMyDestroyableObject
    {
        private static readonly string[] IceAsteroidModels = {
        @"Models\IceAsteroid_1.mwm",
        @"Models\IceAsteroid_2.mwm",
        @"Models\IceAsteroid_3.mwm",
        @"Models\IceAsteroid_4.mwm"
    };

        private static readonly string[] StoneAsteroidModels = {
        @"Models\StoneAsteroid_1.mwm",
        @"Models\StoneAsteroid_2.mwm",
        @"Models\StoneAsteroid_3.mwm",
        @"Models\StoneAsteroid_4.mwm",
        @"Models\StoneAsteroid_5.mwm",
        @"Models\StoneAsteroid_6.mwm",
        @"Models\StoneAsteroid_7.mwm",
        @"Models\StoneAsteroid_8.mwm",
        @"Models\StoneAsteroid_9.mwm",
        @"Models\StoneAsteroid_10.mwm",
        @"Models\StoneAsteroid_11.mwm",
        @"Models\StoneAsteroid_12.mwm",
        @"Models\StoneAsteroid_13.mwm",
        @"Models\StoneAsteroid_14.mwm",
        @"Models\StoneAsteroid_15.mwm",
        @"Models\StoneAsteroid_16.mwm"
    };

        private static readonly string[] IronAsteroidModels = { @"Models\OreAsteroid_Iron.mwm" };
        private static readonly string[] NickelAsteroidModels = { @"Models\OreAsteroid_Nickel.mwm" };
        private static readonly string[] CobaltAsteroidModels = { @"Models\OreAsteroid_Cobalt.mwm" };
        private static readonly string[] MagnesiumAsteroidModels = { @"Models\OreAsteroid_Magnesium.mwm" };
        private static readonly string[] SiliconAsteroidModels = { @"Models\OreAsteroid_Silicon.mwm" };
        private static readonly string[] SilverAsteroidModels = { @"Models\OreAsteroid_Silver.mwm" };
        private static readonly string[] GoldAsteroidModels = { @"Models\OreAsteroid_Gold.mwm" };
        private static readonly string[] PlatinumAsteroidModels = { @"Models\OreAsteroid_Platinum.mwm" };
        private static readonly string[] UraniniteAsteroidModels = { @"Models\OreAsteroid_Uraninite.mwm" };

        private void CreateEffects(Vector3D position)
        {
            MyVisualScriptLogicProvider.CreateParticleEffectAtPosition("roidbreakparticle1", position);
            MyVisualScriptLogicProvider.PlaySingleSoundAtPosition("roidbreak", position);
        }

        public static AsteroidEntity CreateAsteroid(Vector3D position, float size, Vector3D initialVelocity, AsteroidType type)
        {
            var ent = new AsteroidEntity();
            ent.Init(position, size, initialVelocity, type);
            ent.EntityId = ent.EntityId; // EntityId is already assigned by the game
            return ent;
        }

        private void Init(Vector3D position, float size, Vector3D initialVelocity, AsteroidType type)
        {
            try
            {
                Log.Info("Initializing asteroid entity");
                string modPath = Path.Combine(MainSession.I.ModContext.ModPath, "");
                Type = type;
                switch (type)
                {
                    case AsteroidType.Ice:
                        ModelString = Path.Combine(modPath, IceAsteroidModels[MainSession.I.Rand.Next(IceAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Stone:
                        ModelString = Path.Combine(modPath, StoneAsteroidModels[MainSession.I.Rand.Next(StoneAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Iron:
                        ModelString = Path.Combine(modPath, IronAsteroidModels[MainSession.I.Rand.Next(IronAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Nickel:
                        ModelString = Path.Combine(modPath, NickelAsteroidModels[MainSession.I.Rand.Next(NickelAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Cobalt:
                        ModelString = Path.Combine(modPath, CobaltAsteroidModels[MainSession.I.Rand.Next(CobaltAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Magnesium:
                        ModelString = Path.Combine(modPath, MagnesiumAsteroidModels[MainSession.I.Rand.Next(MagnesiumAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Silicon:
                        ModelString = Path.Combine(modPath, SiliconAsteroidModels[MainSession.I.Rand.Next(SiliconAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Silver:
                        ModelString = Path.Combine(modPath, SilverAsteroidModels[MainSession.I.Rand.Next(SilverAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Gold:
                        ModelString = Path.Combine(modPath, GoldAsteroidModels[MainSession.I.Rand.Next(GoldAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Platinum:
                        ModelString = Path.Combine(modPath, PlatinumAsteroidModels[MainSession.I.Rand.Next(PlatinumAsteroidModels.Length)]);
                        break;
                    case AsteroidType.Uraninite:
                        ModelString = Path.Combine(modPath, UraniniteAsteroidModels[MainSession.I.Rand.Next(UraniniteAsteroidModels.Length)]);
                        break;
                }

                Size = size;
                _integrity = AsteroidSettings.BaseIntegrity + Size;

                Log.Info($"Attempting to load model: {ModelString}");

                Init(null, ModelString, null, Size);

                if (string.IsNullOrEmpty(ModelString))
                    Flags &= ~EntityFlags.Visible;

                Save = false;
                NeedsWorldMatrix = true;

                PositionComp.LocalAABB = new BoundingBox(-Vector3.Half * Size, Vector3.Half * Size);

                // Apply random rotation
                var randomRotation = MatrixD.CreateFromQuaternion(Quaternion.CreateFromYawPitchRoll((float)MainSession.I.Rand.NextDouble() * MathHelper.TwoPi, (float)MainSession.I.Rand.NextDouble() * MathHelper.TwoPi, (float)MainSession.I.Rand.NextDouble() * MathHelper.TwoPi));
                WorldMatrix = randomRotation * MatrixD.CreateWorld(position, Vector3D.Forward, Vector3D.Up);
                WorldMatrix.Orthogonalize(); // Normalize the matrix to prevent rotation spazzing

                MyEntities.Add(this);
                Log.Info($"{(MyAPIGateway.Session.IsServer ? "Server" : "Client")}: Added asteroid entity with ID {EntityId} to MyEntities");

                CreatePhysics();
                Physics.LinearVelocity = initialVelocity + RandVector() * AsteroidSettings.VelocityVariability;
                Physics.AngularVelocity = RandVector() * AsteroidSettings.GetRandomAngularVelocity(MainSession.I.Rand); // Set initial angular velocity

                Log.Info($"Asteroid model {ModelString} loaded successfully with initial angular velocity: {Physics.AngularVelocity}");

                if (MyAPIGateway.Session.IsServer)
                {
                    SyncFlag = true;
                }
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(AsteroidEntity), $"Failed to load model: {ModelString}");
                Flags &= ~EntityFlags.Visible;
            }
        }

        public float Size;
        public string ModelString = "";
        public AsteroidType Type;
        private float _integrity;

        public void SplitAsteroid()
        {
            int splits = MainSession.I.Rand.Next(2, 5);

            if (splits > Size)
                splits = (int)Math.Ceiling(Size);

            float newSize = Size / splits;

            CreateEffects(PositionComp.GetPosition());

            if (newSize <= AsteroidSettings.MinSubChunkSize)
            {
                MyPhysicalItemDefinition item = MyDefinitionManager.Static.GetPhysicalItemDefinition(new MyDefinitionId(typeof(MyObjectBuilder_Ore), Type.ToString()));
                var newObject = MyObjectBuilderSerializer.CreateNewObject(item.Id.TypeId, item.Id.SubtypeId.ToString()) as MyObjectBuilder_PhysicalObject;
                for (int i = 0; i < splits; i++)
                {
                    int dropAmount = GetRandomDropAmount(Type);
                    MyFloatingObjects.Spawn(new MyPhysicalInventoryItem(dropAmount, newObject), PositionComp.GetPosition() + RandVector() * Size, Vector3D.Forward, Vector3D.Up, Physics);
                }

                // Send a removal message before closing
                if (MyAPIGateway.Utilities.IsDedicated || !MyAPIGateway.Session.IsServer)
                {
                    var removalMessage = new AsteroidNetworkMessage(PositionComp.GetPosition(), Size, Vector3D.Zero, Vector3D.Zero, Type, false, EntityId, true, false);
                    var removalMessageBytes = MyAPIGateway.Utilities.SerializeToBinary(removalMessage);
                    MyAPIGateway.Multiplayer.SendMessageToOthers(32000, removalMessageBytes);
                }

                // Remove from asteroid list
                MainSession.I._spawner._asteroids.Remove(this);

                Close();
                return;
            }

            for (int i = 0; i < splits; i++)
            {
                Vector3D newPos = PositionComp.GetPosition() + RandVector() * Size;
                Vector3D newVelocity = RandVector() * AsteroidSettings.GetRandomSubChunkVelocity(MainSession.I.Rand);
                Vector3D newAngularVelocity = RandVector() * AsteroidSettings.GetRandomSubChunkAngularVelocity(MainSession.I.Rand);

                var subChunk = CreateAsteroid(newPos, newSize, newVelocity, Type);
                subChunk.Physics.AngularVelocity = newAngularVelocity;

                // Add sub-chunks to the asteroid list
                MainSession.I._spawner._asteroids.Add(subChunk);

                // Send a network message to clients
                if (MyAPIGateway.Utilities.IsDedicated || !MyAPIGateway.Session.IsServer)
                {
                    var message = new AsteroidNetworkMessage(newPos, newSize, newVelocity, newAngularVelocity, Type, true, subChunk.EntityId, false, true);
                    var messageBytes = MyAPIGateway.Utilities.SerializeToBinary(message);
                    MyAPIGateway.Multiplayer.SendMessageToOthers(32000, messageBytes);
                }
            }

            // Send a removal message before closing
            if (MyAPIGateway.Utilities.IsDedicated || !MyAPIGateway.Session.IsServer)
            {
                var removalMessage = new AsteroidNetworkMessage(PositionComp.GetPosition(), Size, Vector3D.Zero, Vector3D.Zero, Type, false, EntityId, true, false);
                var removalMessageBytes = MyAPIGateway.Utilities.SerializeToBinary(removalMessage);
                MyAPIGateway.Multiplayer.SendMessageToOthers(32000, removalMessageBytes);
            }

            // Remove from asteroid list
            MainSession.I._spawner._asteroids.Remove(this);

            Close();
        }

        private int GetRandomDropAmount(AsteroidType type)
        {
            switch (type)
            {
                case AsteroidType.Ice:
                    return MainSession.I.Rand.Next(AsteroidSettings.IceDropRange[0], AsteroidSettings.IceDropRange[1]);
                case AsteroidType.Stone:
                    return MainSession.I.Rand.Next(AsteroidSettings.StoneDropRange[0], AsteroidSettings.StoneDropRange[1]);
                case AsteroidType.Iron:
                    return MainSession.I.Rand.Next(AsteroidSettings.IronDropRange[0], AsteroidSettings.IronDropRange[1]);
                case AsteroidType.Nickel:
                    return MainSession.I.Rand.Next(AsteroidSettings.NickelDropRange[0], AsteroidSettings.NickelDropRange[1]);
                case AsteroidType.Cobalt:
                    return MainSession.I.Rand.Next(AsteroidSettings.CobaltDropRange[0], AsteroidSettings.CobaltDropRange[1]);
                case AsteroidType.Magnesium:
                    return MainSession.I.Rand.Next(AsteroidSettings.MagnesiumDropRange[0], AsteroidSettings.MagnesiumDropRange[1]);
                case AsteroidType.Silicon:
                    return MainSession.I.Rand.Next(AsteroidSettings.SiliconDropRange[0], AsteroidSettings.SiliconDropRange[1]);
                case AsteroidType.Silver:
                    return MainSession.I.Rand.Next(AsteroidSettings.SilverDropRange[0], AsteroidSettings.SilverDropRange[1]);
                case AsteroidType.Gold:
                    return MainSession.I.Rand.Next(AsteroidSettings.GoldDropRange[0], AsteroidSettings.GoldDropRange[1]);
                case AsteroidType.Platinum:
                    return MainSession.I.Rand.Next(AsteroidSettings.PlatinumDropRange[0], AsteroidSettings.PlatinumDropRange[1]);
                case AsteroidType.Uraninite:
                    return MainSession.I.Rand.Next(AsteroidSettings.UraniniteDropRange[0], AsteroidSettings.UraniniteDropRange[1]);
                default:
                    return 0;
            }
        }

        public void OnDestroy()
        {
            try
            {
                SplitAsteroid();
            }
            catch (Exception ex)
            {
                Log.Exception(ex, typeof(AsteroidEntity), "Exception in OnDestroy:");
                throw; // Rethrow the exception for the debugger
            }
        }

        public bool DoDamage(float damage, MyStringHash damageSource, bool sync, MyHitInfo? hitInfo = null, long attackerId = 0, long realHitEntityId = 0, bool shouldDetonateAmmo = true, MyStringHash? extraInfo = null)
        {
            //Disabling explosion damage is an awful way to fix this weird rocket bug, but it's okay we'll be using weaponcore :)
            var explosionDamageType = MyStringHash.GetOrCompute("Explosion");

            // Check if the damage source is explosion
            if (damageSource == explosionDamageType)
            {
                Log.Info($"Ignoring explosion damage for asteroid. Damage source: {damageSource.String}");
                return false; // Ignore the damage
            }

            _integrity -= damage;
            Log.Info($"DoDamage called with damage: {damage}, damageSource: {damageSource.String}, attackerId: {attackerId}, realHitEntityId: {realHitEntityId}, new integrity: {_integrity}");

            if (hitInfo.HasValue)
            {
                var hit = hitInfo.Value;
                Log.Info($"HitInfo - Position: {hit.Position}, Normal: {hit.Normal}, Velocity: {hit.Velocity}");
            }

            if (Integrity < 0)
            {
                Log.Info("Integrity below 0, calling OnDestroy");
                OnDestroy();
            }
            return true;
        }

        public float Integrity => _integrity;

        public bool UseDamageSystem => true;

        private void CreatePhysics()
        {
            float mass = 10000 * Size * Size * Size;
            float radius = Size / 2; // Assuming Size represents the diameter

            PhysicsSettings settings = MyAPIGateway.Physics.CreateSettingsForPhysics(
                this,
                WorldMatrix,
                Vector3.Zero,
                linearDamping: 0f, // Remove damping
                angularDamping: 0f, // Remove damping
                rigidBodyFlags: RigidBodyFlag.RBF_DEFAULT,
                collisionLayer: CollisionLayers.NoVoxelCollisionLayer,
                isPhantom: false,
                mass: new ModAPIMass(PositionComp.LocalAABB.Volume(), mass, Vector3.Zero, mass * PositionComp.LocalAABB.Height * PositionComp.LocalAABB.Height / 6 * Matrix.Identity)
            );

            MyAPIGateway.Physics.CreateSpherePhysics(settings, radius);
            Physics.Enabled = true;
            Physics.Activate();
        }

        private Vector3D RandVector()
        {
            var theta = MainSession.I.Rand.NextDouble() * 2.0 * Math.PI;
            var phi = Math.Acos(2.0 * MainSession.I.Rand.NextDouble() - 1.0);
            var sinPhi = Math.Sin(phi);
            return Math.Pow(MainSession.I.Rand.NextDouble(), 1 / 3d) * new Vector3D(sinPhi * Math.Cos(theta), sinPhi * Math.Sin(theta), Math.Cos(phi));
        }

    }
}
﻿using DynamicAsteroids.AsteroidEntities;
using DynamicAsteroids;
using Sandbox.ModAPI;
using SC.SUGMA;
using System.Collections.Generic;
using System;
using VRage.Game.ModAPI;
using VRage.ModAPI;
using VRageMath;
using System.Linq;
using Sandbox.Game.Entities;

public class AsteroidSpawner
{
    public List<AsteroidEntity> _asteroids;
    private bool _canSpawnAsteroids = false;
    private DateTime _worldLoadTime;
    private Random rand;
    private List<AsteroidState> _despawnedAsteroids = new List<AsteroidState>();
    private List<AsteroidNetworkMessage> _networkMessages = new List<AsteroidNetworkMessage>();


    public void Init(int seed)
    {
        if (!MyAPIGateway.Session.IsServer)
            return;

        Log.Info("Initializing AsteroidSpawner");
        _asteroids = new List<AsteroidEntity>(AsteroidSettings.MaxAsteroidCount);
        _worldLoadTime = DateTime.UtcNow;
        rand = new Random(seed);
        AsteroidSettings.Seed = seed;
    }

    public void SaveAsteroidState()
    {
        if (!MyAPIGateway.Session.IsServer || !AsteroidSettings.EnablePersistence)
            return;

        var asteroidStates = _asteroids.Select(asteroid => new AsteroidState
        {
            Position = asteroid.PositionComp.GetPosition(),
            Size = asteroid.Size,
            Type = asteroid.Type,
            EntityId = asteroid.EntityId // Save unique ID
        }).ToList();

        asteroidStates.AddRange(_despawnedAsteroids);

        var stateBytes = MyAPIGateway.Utilities.SerializeToBinary(asteroidStates);
        using (var writer = MyAPIGateway.Utilities.WriteBinaryFileInLocalStorage("asteroid_states.dat", typeof(AsteroidSpawner)))
        {
            writer.Write(stateBytes, 0, stateBytes.Length);
        }
    }

    public void LoadAsteroidState()
    {
        if (!MyAPIGateway.Session.IsServer || !AsteroidSettings.EnablePersistence)
            return;

        _asteroids.Clear();

        if (MyAPIGateway.Utilities.FileExistsInLocalStorage("asteroid_states.dat", typeof(AsteroidSpawner)))
        {
            byte[] stateBytes;
            using (var reader = MyAPIGateway.Utilities.ReadBinaryFileInLocalStorage("asteroid_states.dat", typeof(AsteroidSpawner)))
            {
                stateBytes = reader.ReadBytes((int)reader.BaseStream.Length);
            }

            var asteroidStates = MyAPIGateway.Utilities.SerializeFromBinary<List<AsteroidState>>(stateBytes);

            foreach (var state in asteroidStates)
            {
                if (_asteroids.Any(a => a.EntityId == state.EntityId))
                {
                    Log.Info($"Skipping duplicate asteroid with ID {state.EntityId}");
                    continue; // Skip duplicates
                }

                var asteroid = AsteroidEntity.CreateAsteroid(state.Position, state.Size, Vector3D.Zero, state.Type);
                asteroid.EntityId = state.EntityId; // Assign the saved ID
                _asteroids.Add(asteroid);
                MyEntities.Add(asteroid);
            }
        }
    }

    private void LoadAsteroidsInRange(Vector3D playerPosition)
    {
        foreach (var state in _despawnedAsteroids.ToArray())
        {
            double distanceSquared = Vector3D.DistanceSquared(state.Position, playerPosition);

            if (distanceSquared < AsteroidSettings.AsteroidSpawnRadius * AsteroidSettings.AsteroidSpawnRadius)
            {
                bool tooClose = _asteroids.Any(a => Vector3D.DistanceSquared(a.PositionComp.GetPosition(), state.Position) < AsteroidSettings.MinDistanceFromPlayer * AsteroidSettings.MinDistanceFromPlayer);
                bool exists = _asteroids.Any(a => a.EntityId == state.EntityId); // Check for existing IDs

                if (tooClose || exists)
                {
                    Log.Info($"Skipping respawn of asteroid at {state.Position} due to proximity to other asteroids or duplicate ID");
                    continue;
                }

                Log.Info($"Respawning asteroid at {state.Position} due to player re-entering range");
                var asteroid = AsteroidEntity.CreateAsteroid(state.Position, state.Size, Vector3D.Zero, state.Type);
                asteroid.EntityId = state.EntityId; // Assign the saved ID
                _asteroids.Add(asteroid);

                var message = new AsteroidNetworkMessage(state.Position, state.Size, Vector3D.Zero, Vector3D.Zero, state.Type, false, asteroid.EntityId, false, true);
                var messageBytes = MyAPIGateway.Utilities.SerializeToBinary(message);
                MyAPIGateway.Multiplayer.SendMessageToOthers(32000, messageBytes);

                _despawnedAsteroids.Remove(state);
            }
        }
    }

    public void Close()
    {
        if (!MyAPIGateway.Session.IsServer)
            return;

        SaveAsteroidState();
        Log.Info("Closing AsteroidSpawner");
        _asteroids?.Clear();
    }

    private int _spawnIntervalTimer = 0;
    private int _updateIntervalTimer = 0;

    public void UpdateTick()
    {
        if (!MyAPIGateway.Session.IsServer)
            return;

        // Check if 10 seconds have passed since the world loaded
        if (!_canSpawnAsteroids)
        {
            if ((DateTime.UtcNow - _worldLoadTime).TotalSeconds < 10)
            {
                return;
            }
            _canSpawnAsteroids = true;
        }

        try
        {
            List<IMyPlayer> players = new List<IMyPlayer>();
            MyAPIGateway.Players.GetPlayers(players);

            foreach (var player in players)
            {
                Vector3D playerPosition = player.GetPosition();

                // Update asteroids at a slower interval
                if (_updateIntervalTimer > 0)
                {
                    _updateIntervalTimer--;
                }
                else
                {
                    UpdateAsteroids(playerPosition);
                    _updateIntervalTimer = AsteroidSettings.UpdateInterval; // Use setting
                }

                // Spawn asteroids at a slower interval
                if (_spawnIntervalTimer > 0)
                {
                    _spawnIntervalTimer--;
                }
                else
                {
                    SpawnAsteroids(playerPosition);
                    _spawnIntervalTimer = AsteroidSettings.SpawnInterval; // Use setting
                }

                // Load asteroids in range
                LoadAsteroidsInRange(playerPosition);

                if (AsteroidSettings.EnableLogging)
                    MyAPIGateway.Utilities.ShowNotification($"Active Asteroids: {_asteroids.Count}", 1000 / 60);
            }
        }
        catch (Exception ex)
        {
            Log.Exception(ex, typeof(AsteroidSpawner));
        }
    }

    private void UpdateAsteroids(Vector3D playerPosition)
    {
        foreach (var asteroid in _asteroids.ToArray())
        {
            double distanceSquared = Vector3D.DistanceSquared(asteroid.PositionComp.GetPosition(), playerPosition);

            // Remove asteroids that are outside the spherical spawn radius
            if (distanceSquared > AsteroidSettings.AsteroidSpawnRadius * AsteroidSettings.AsteroidSpawnRadius)
            {
                Log.Info($"Removing asteroid at {asteroid.PositionComp.GetPosition()} due to distance from player");
                RemoveAsteroid(asteroid);
            }
        }
    }

    private void SpawnAsteroids(Vector3D playerPosition)
    {
        int asteroidsSpawned = 0;
        int spawnAttempts = 0;
        int maxAttempts = 50; // Limit the number of attempts to find valid positions

        while (_asteroids.Count < AsteroidSettings.MaxAsteroidCount && asteroidsSpawned < 10)
        {
            if (spawnAttempts >= maxAttempts)
            {
                Log.Info("Reached maximum spawn attempts, breaking out of loop to prevent freeze");
                break;
            }

            Vector3D newPosition;
            do
            {
                newPosition = playerPosition + RandVector() * AsteroidSettings.AsteroidSpawnRadius;
                spawnAttempts++;
            } while (Vector3D.DistanceSquared(newPosition, playerPosition) < AsteroidSettings.MinDistanceFromPlayer * AsteroidSettings.MinDistanceFromPlayer && spawnAttempts < maxAttempts);

            if (spawnAttempts >= maxAttempts)
                break;

            Vector3D newVelocity;
            if (!AsteroidSettings.CanSpawnAsteroidAtPoint(newPosition, out newVelocity))
                continue;

            if (IsNearVanillaAsteroid(newPosition))
            {
                Log.Info("Skipped spawning asteroid due to proximity to vanilla asteroid.");
                continue;
            }

            AsteroidType type = AsteroidSettings.GetAsteroidType(newPosition);
            float size = AsteroidSettings.GetAsteroidSize(newPosition);

            Log.Info($"Spawning asteroid at {newPosition} with velocity {newVelocity} of type {type}");
            var asteroid = AsteroidEntity.CreateAsteroid(newPosition, size, newVelocity, type);
            _asteroids.Add(asteroid);
            Log.Info($"Server: Added new asteroid with ID {asteroid.EntityId} to _asteroids list");

            var message = new AsteroidNetworkMessage(newPosition, size, newVelocity, Vector3D.Zero, type, false, asteroid.EntityId, false, true);
            _networkMessages.Add(message);  // Add to the list instead of sending immediately

            asteroidsSpawned++;
        }
    }

    public void SendNetworkMessages()
    {
        if (_networkMessages.Count == 0) return;
        try
        {
            Log.Info($"Server: Preparing to send {_networkMessages.Count} network messages");
            var messageBytes = MyAPIGateway.Utilities.SerializeToBinary(_networkMessages);
            Log.Info($"Server: Serialized message size: {messageBytes.Length} bytes");
            MyAPIGateway.Multiplayer.SendMessageToOthers(32000, messageBytes);
            Log.Info($"Server: Sent {_networkMessages.Count} network messages");
            _networkMessages.Clear();
        }
        catch (Exception ex)
        {
            Log.Exception(ex, typeof(AsteroidSpawner), "Failed to send network messages");
        }
    }


    private void RemoveAsteroid(AsteroidEntity asteroid)
    {
        if (_asteroids.Any(a => a.EntityId == asteroid.EntityId))
        {
            _despawnedAsteroids.Add(new AsteroidState
            {
                Position = asteroid.PositionComp.GetPosition(),
                Size = asteroid.Size,
                Type = asteroid.Type,
                EntityId = asteroid.EntityId
            });

            var removalMessage = new AsteroidNetworkMessage(asteroid.PositionComp.GetPosition(), asteroid.Size, Vector3D.Zero, Vector3D.Zero, asteroid.Type, false, asteroid.EntityId, true, false);
            var removalMessageBytes = MyAPIGateway.Utilities.SerializeToBinary(removalMessage);
            MyAPIGateway.Multiplayer.SendMessageToOthers(32000, removalMessageBytes);

            _asteroids.Remove(asteroid);
            asteroid.Close();
            MyEntities.Remove(asteroid);
            Log.Info($"Server: Removed asteroid with ID {asteroid.EntityId} from _asteroids list and MyEntities");
        }
    }

    private bool IsNearVanillaAsteroid(Vector3D position)
    {
        List<IMyVoxelBase> voxelMaps = new List<IMyVoxelBase>();
        MyAPIGateway.Session.VoxelMaps.GetInstances(voxelMaps, v => v is IMyVoxelMap && !v.StorageName.StartsWith("mod_"));

        foreach (var voxelMap in voxelMaps)
        {
            if (Vector3D.DistanceSquared(position, voxelMap.GetPosition()) < AsteroidSettings.MinDistanceFromVanillaAsteroids * AsteroidSettings.MinDistanceFromVanillaAsteroids)
            {
                Log.Info($"Position {position} is near vanilla asteroid {voxelMap.StorageName}");
                return true;
            }
        }

        return false;
    }

    private Vector3D RandVector()
    {
        var theta = rand.NextDouble() * 2.0 * Math.PI;
        var phi = Math.Acos(2.0 * rand.NextDouble() - 1.0);
        var sinPhi = Math.Sin(phi);
        return Math.Pow(rand.NextDouble(), 1 / 3d) * new Vector3D(sinPhi * Math.Cos(theta), sinPhi * Math.Sin(theta), Math.Cos(phi));
    }
}
